from commons import *
from Crypto.Util.number import long_to_bytes


def main():

  n = 110581795715958566206600392161360212579669637391437097703685154237017351570464767725324182051199901920318211290404777259728923614917211291562555864753005179326101890427669819834642007924406862482343614488768256951616086287044725034412802176312273081322195866046098595306261781788276570920467840172004530873767
  e = 1
  ct = 44981230718212183604274785925793145442655465025264554046028251311164494127485

  # https://stackoverflow.com/a/17490874
  # d * e = 1 mod (p-1)(q-1)
  # skoro e = 1, to d = 1 mod (totient_of_N)
  # dalej, szyfrogram tworzy się przez ct = pow(message, e, N)
  # ct = pow(message, 1, N) -> ct = message mod N
  # nie było zadnego dzielenia modulo, to nie zostalo zaszyfrowane wcale

  print(long_to_bytes(ct))


if __name__ == '__main__':
  main()